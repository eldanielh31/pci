<!doctype html>
<head>
<meta charset="utf-8">
<title>9.2 Probe Samplers</title>
<link rel="stylesheet" href="simics.css">
<script>function postUrl() {
    window.parent.postMessage({ content_url: window.location.href }, "*");
}
if (window.parent != null && window.parent != window) {
    postUrl();
    window.addEventListener("hashchange", function () {
        postUrl();
    });
} else {
    // Check if we are part of a Simics doc site and redirect if we are
    fetch("../simics-doc-site-marker", { method: "HEAD" }).then(response => {
        if (response.ok) {
            window.location = "..#" + window.location.href;
        } else {
            console.info("Not part of a Simics documentation site");
        }
    }).catch(error => {
        console.warn("Failed to check if this is a Simics documentation site:",
            error);
    });
}</script>
</head>
<div class="chain">
<a href="probes-command-set.html">9.1 Probes Command Set</a>
<a href="low-level-debugging.html">III Low-Level Debugging</a>
</div>
<div class="path">
<a href="index.html">Simics User's Guide</a>
&nbsp;/&nbsp;
<a href="feature-overview.html">II Feature Overview</a>
&nbsp;/&nbsp;
<a href="probes.html">9 Probes</a>
&nbsp;/&nbsp;</div>
<h1 class="jdocu"><a name="Probe-Samplers">9.2 Probe Samplers</a></h1>
<p>
  
</p><p>
  Probe samplers are a group of tools which use sampling during the
  simulation, to read user-configurable probes and displays their
  values. This captures deviations of the probes during the
  simulation, compared to just looking at the end result when the
  simulation is finished.
  </p><p>
  Probe samplers are a group of tools which read user-configurable
  probes during simulation, through sampling. This captures
  deviations of the probes during the simulation, compared to just
  looking at the end result when the simulation is finished.
</p><p>
  By default, added probes are all sampled and printed out during
  run-time with one row representing each sample, each column
  representing a particular probe.
  </p><p>
  With many probes sampled, the table can become very wide, and hard
  to read. To avoid this, a probe can be added with special flags:
  </p><ul>
    <li><b>-no-sampling</b> Do not sample the probe, but present the
      end value in the summary. This can be handy for probes where it
      is not interesting to know what happened during the simulation
      but the final value is of interest.</li>
    <li><b>-hidden</b> Do not display the probe in each sample on
      screen during simulation. The data is still recorded and can be
      viewed or saved later.</li>
  </ul>
  <p>
  The result of the measurements can be saved to <code>csv</code>
  or <code>json</code> formats. There are also plot capabilities built
  in the tools when connected to Simics-client.
</p><p>
  There are three different samplers, with very similar command sets.
  To create one of these samplers, the <b>new-probe-monitor</b>,
  <b>new-probe-streamer</b> or <b>new-system-perfmeter</b>
  is used. Since the command interface for these tools are largely
  identical, the probe-monitor chapter explains details which are
  generally applicable.
  </p><p>
  </p><h2 class="jdocu"><a name="Probe-Monitor">9.2.1 Probe Monitor</a></h2>
<p>
  
</p><p>
  The <code>probe-monitor</code> tool offers a way to read out and present
  the probe values in continuous samples, while the simulation is
  running.
  </p><p>
  All probes being monitored will be presented in a table row
  for each sample taken, allowing detection of abnormal values
  during the simulation.
</p><p>
  It is possible to add lots of probes to the same probe-monitor,
  but as the number of probes increase, so does the width of the
  produced table. Therefore, it can be useful to create several
  probe-monitors, each showing some group of related feature.
</p><p>
  To create a probe-monitor use the <b>new-probe-monitor</b>
  command. This will create a new object such as <code>pm0</code>
  which has some additional commands.
  See figure <a class="reference" href="#pm-example">25</a> for an example.
</p><p>
  </p><div class="figure" id="pm-example">

    <pre class="jdocu_small">$&gt; <b>./simics targets/qsp-x86/firststeps.simics num_cores=2</b>
simics&gt; <b>new-probe-monitor sampling-mode = realtime interval = 1 -summary</b>      
simics&gt; <b>pm0.add-probe probe-kind = sim.time.wallclock sim.time.virtual mode = session</b>
simics&gt; <b>pm0.add-probe probe-kind = sim.time.schedule sim.slowdown sim.esteps sim.mips cpu.esteps cpu.time.schedule cpu.schedule_percent cpu.mips</b>
simics&gt; <b>run-seconds 60</b>
┌──────────────────────────────────────────────────────────────┬──────────────────────────────────────┬──────────────────────────────────────┐
│                                                              │       board.mb.cpu0.core[0][0]       │       board.mb.cpu0.core[1][0]       │
├──────────┬──────────┬─────────┬────────┬────────────┬────────┼────────────┬─────────┬──────┬────────┼────────────┬─────────┬──────┬────────┤
│ Session  │ Session  │Sched (s)│Slowdown│   Esteps   │  IPS   │   Esteps   │Sched (s)│Sched%│  IPS   │   Esteps   │Sched (s)│Sched%│  IPS   │
│Wallclock │ Virtual- │         │        │            │        │            │         │      │        │            │         │      │        │
│(hh:mm:ss)│   Time   │         │        │            │        │            │         │      │        │            │         │      │        │
│          │(hh:mm:ss)│         │        │            │        │            │         │      │        │            │         │      │        │
├──────────┼──────────┼─────────┼────────┼────────────┼────────┼────────────┼─────────┼──────┼────────┼────────────┼─────────┼──────┼────────┤
│  00:00:01│  00:00:01│311.92 ms│    0.59│   462112845│872.65 M│   462021371│297.54 ms│   95%│  1.55 G│       91474│ 14.38 ms│    5%│  6.36 M│
│  00:00:02│  00:00:04│445.62 ms│    0.29│   252202461│251.80 M│   252171406│432.12 ms│   97%│583.56 M│       31055│ 13.50 ms│    3%│  2.30 M│
│  00:00:03│  00:00:22│999.63 ms│    0.06│    54925316│ 54.86 M│    54925316│959.26 ms│   96%│ 57.26 M│           0│ 40.37 ms│    4%│  0.00  │
│  00:00:04│  00:00:40│995.50 ms│    0.06│    55920137│ 55.86 M│    55920137│955.12 ms│   96%│ 58.55 M│           0│ 40.38 ms│    4%│  0.00  │
│  00:00:05│  00:00:54│997.73 ms│    0.07│   798812869│798.45 M│   798792570│964.31 ms│   97%│828.36 M│       20299│ 33.42 ms│    3%│607.45 k│
│  00:00:06│  00:00:55│998.69 ms│    0.61│  3001496016│  3.00 G│  2927954125│941.13 ms│   94%│  3.11 G│    73541891│ 57.56 ms│    6%│  1.28 G│
│  00:00:07│  00:00:59│966.83 ms│    0.33│   548000049│547.45 M│   184324157│491.32 ms│   51%│375.16 M│   363675892│475.51 ms│   49%│764.82 M│
│  00:00:08│  00:00:59│994.97 ms│    2.38│  1178737071│  1.18 G│   643116292│395.46 ms│   40%│  1.63 G│   535620779│599.52 ms│   60%│893.42 M│
│  00:00:09│  00:01:00│998.21 ms│    1.30│  2418507935│  2.42 G│  1159903342│565.55 ms│   57%│  2.05 G│  1258604593│432.66 ms│   43%│  2.91 G│
</pre><p>
</p><div class="caption">Figure 25. Sample probe-monitor session</div>
</div>
  
<p>
  Here, first a probe-monitor is created, that gets the name <code>pm0</code> by default.
  The probe-monitor samples the probes each wallclock seconds, which is controlled by the
  <code>mode</code> and <code>interval</code> arguments.
</p><p>
  The <code>-summary</code> flag means all probe values will be displayed
  when the simulation stops, providing the session or current value
  for the probes subscribed to, described later.
</p><p>
  Next, the <b>pm0.add-probe</b> is issued with two probe-kinds using
  the mode <code>session</code>.  If mode is not specified, it defaults
  to <code>delta</code> meaning the value presented for the probe is the
  difference from the previous sample. That is, it shows the value for
  the sample only.  With the <code>session</code> mode, it instead shows
  the total value since the probe was added to the monitor. In this case,
  the accumulated times, both in host wall-clock and the virtual time
  of the simulated system is displayed.
  </p><p>
  Apart from <code>session</code> and <code>delta</code> there is also
  the <code>current</code> mode which can be selected, which displays the
  plain probe value, without any adjustments. The <code>current</code>
  mode is interesting for some probes, which are not monotonically
  increasing, such as a temperature. It can also be interesting to be
  used for probes derived from checkpointed state, for example the
  global virtual time, when the user wants to see the absolute time.
</p><p>
  Finally, before the execution is started we add more probes,
  now using the default <code>delta</code> mode. Here we are mixing
  some singleton probes <code>sim.*</code> and some processor specific
  probes <code>cpu.*</code>. Since there are two processors in the simulated system
  used in this example, the number of all monitored probes is 14.
</p><p>
  When the simulation is started, the probe-monitor starts to print
  out table rows for the probes being measured, one second between
  each sample. Probes which have an object associated will be
  sorted under that object, so here probes for the two processors
  have an additional heading showing where the probes belong to.
</p><p>
  Some more detailed information on each column or probe, that was monitored
  in this example.
</p><p>
  </p><dl><dt id="dt:session-wallclock-hh-mm-ss-sim-time-wallclock"><b>Session Wallclock (hh:mm:ss) - <i>sim.time.wallclock</i></b></dt><dd>This is basically the host time that has elapsed during the
      simulation.  Note that this time stands still if Simics is not
      executing.  If the true wallclock is desired (which increments
      even when Simics is not simulating), the
      probe <code>host.time.wallclock</code> can be used instead.  The
      time here is presented as hours, minutes and second format.
    </dd><dt id="dt:session-virtual-time-hh-mm-ss-sim-time-virtual"><b>Session Virtual-Time (hh:mm:ss) - <i>sim.time.virtual</i></b></dt><dd>This probe returns the virtual time of the simulation.  The
      virtual time for all processors are pretty much in sync, but
      there can be small differences. The probe simply selects the
      first processor that it finds and presents that.  Similar to
      wall clock, and all <code>session</code> or
      <code>current</code> times are presented in hours, minutes and
      second format.
    </dd><dt id="dt:sched-s-sim-time-schedule"><b>Sched (s) - <i>sim.time.schedule</i></b></dt><dd>This is another aspect of time in Simics, namely how much time
      that Simics scheduler have requested the different processor to
      be scheduled in total. In a multi-threaded simulation this time
      can be much greater than the wallclock time, since each
      execution thread can run in parallel.  The monitor presents any
      delta times with a second metric-prefix, giving much higher
      resolution.
    </dd><dt id="dt:slowdown-sim-slowdown"><b>Slowdown - <i>sim.slowdown</i></b></dt><dd>The slowdown probes gives an measurement on how fast virtual
      time elapses compared to wallclock time. Any value below one
      means that the virtual time goes faster then the host wallclock.
      This provides a hint on how fast the simulation is.
      <p>
      A value of 0.5 means Simics simulation goes twice as fast as the
      simulated virtual system, while a figure of 2.0 means the simulation goes in
      half the speed compared to the simulated system. 
</p><p>
      </p><div class="note">
<b>Note:</b>
Don't take this figure for any kind of exactness to the real system,
	sim.time.virtual depends on:
	<ul>
	  <li>The frequency of the simulated processors.</li>
	  <li>A simplistic timing models where typically one
	    instruction always takes one cycle to execute.</li>
	  <li>Device models are also typically simplistic on how fast
	    transfers and interrupts occur.</li>
	  <li>Idle processor can typically consume cycles almost
	    infinitely fast, which does not happen in real
	    hardware.</li>
	</ul>
	How fast Simics executes also depends on how many processors
	it schedules, the processor models, the type of workload,
	threading settings, internal caches and much more.
	Thus, one needs to take the slowdown figure with a grain of
	salt, before comparing with other sessions, or even with
	just with different workloads.
      </div></dd><dt id="dt:esteps-sim-esteps"><b>Esteps - <i>sim.esteps</i></b></dt><dd>Steps in Simics are roughly equivalent to instructions.  Some
      processor models however can consume steps while they are
      stalled. Therefore, the esteps (executed steps) metric is better
      suited for counting instructions, where the halt-steps have been
      subtracted from the steps counter.  The simulator
      global <code>sim.esteps</code> is the total of
      all <code>cpu.esteps</code> in the system.
    </dd><dt id="dt:ips-sim-mips"><b>IPS - <i>sim.mips</i></b></dt><dd>(M)IPS is an acronym of (Million) Instructions Per
      Second. This is a common measurement for looking at the how fast
      the simulation is. It is calculated as <code>sim.esteps /
      sim.time.wallclock</code>. Note that, depending on the simulation
      speed, other prefixes then <code>M</code> is used each sample, for
      example <code>G</code> for GIPS, or <code>k</code> for kIPS.
    </dd><dt id="dt:esteps-cpu-esteps"><b>Esteps - <i>cpu.esteps</i></b></dt><dd>The processor specific number of executed steps.
    </dd><dt id="dt:sched-s-cpu-time-schedule"><b>Sched (s) - <i>cpu.time.schedule</i></b></dt><dd>The amount of time Simics scheduler has scheduled this processor.
    </dd><dt id="dt:sched-cpu-schedule_percent"><b>Sched% - <i>cpu.schedule_percent</i></b></dt><dd>This probe gives a percent value of how much of the time this
      processor has been scheduled
      <code>cpu.time.schedule / sim.time.schedule</code>
      This can be used to detect bottle-necks in the simulation, if
      one processor stands for the majority of the time.
    </dd><dt id="dt:ips-cpu-mips"><b>IPS - <i>cpu.mips</i></b></dt><dd>This probe might look like <code>sim.mips</code> but is actually a
      bit different.  The processor specific MIPS number is calculated
      as:
      <code>cpu.esteps / cpu.time.schedule</code>.  This means that the
      MIPS numbers here cannot be added together.  Instead this gives
      an indication of how fast this particular processor executes,
      given the amount of time it got.  This can be used to detect
      sub-optimal processor simulation even if the processor runs at a
      much lower frequency, and consequently is not scheduled as much.
    </dd></dl><p>When the simulation is finished, the probe-monitor shows a table
  of all the probes that are monitored. The table provides the current
  value for all probes, see figure <a class="reference" href="#pm-summary-example">26</a> for
  the example output.
  </p><p>
  </p><div class="figure" id="pm-summary-example">

    <pre class="jdocu_small">┌─────┬────────────┬────────────────────┬────────────────────────┬───────────────────────┐
│Row #│Display Name│     Probe-kind     │         Object         │Session Formatted Value│
├─────┼────────────┼────────────────────┼────────────────────────┼───────────────────────┤
│    1│Wallclock   │sim.time.wallclock  │sim                     │            00:00:09.09│
│    2│Virtual-Time│sim.time.virtual    │sim                     │            00:01:00.00│
│    3│Sched       │sim.time.schedule   │sim                     │            00:00:08.27│
│    4│Slowdown    │sim.slowdown        │sim                     │                   0.15│
│    5│Esteps      │sim.esteps          │sim                     │             9512224930│
│    6│IPS         │sim.mips            │sim                     │                 1.05 G│
│    7│Esteps      │cpu.esteps          │board.mb.cpu0.core[0][0]│             6853454540│
│    8│Sched       │cpu.time.schedule   │board.mb.cpu0.core[0][0]│            00:00:06.43│
│    9│Sched%      │cpu.schedule_percent│board.mb.cpu0.core[0][0]│                    78%│
│   10│IPS         │cpu.mips            │board.mb.cpu0.core[0][0]│                 1.07 G│
│   11│Esteps      │cpu.esteps          │board.mb.cpu0.core[1][0]│             2658770390│
│   12│Sched       │cpu.time.schedule   │board.mb.cpu0.core[1][0]│            00:00:01.84│
│   13│Sched%      │cpu.schedule_percent│board.mb.cpu0.core[1][0]│                    22%│
│   14│IPS         │cpu.mips            │board.mb.cpu0.core[1][0]│                 1.45 G│
└─────┴────────────┴────────────────────┴────────────────────────┴───────────────────────┘
</pre><p>
</p><div class="caption">Figure 26. Probe-Monitor Summary Printout</div>
</div>
  
<p>
  The <i>Session Formatted Value</i> represents the probe value
  formatted accordingly to the probe properties. If probes have been
  added with the <code>current</code> mode then an additional <i>Current
  Formatted Value</i> column is also displayed.
  </p><p>
  It is also possible to get the same results printed out with
  the <b>pm0.summary</b> command, where it is possible to request
  more floating point decimals to be presented with
  the <code>float-decimals</code> argument.
</p><p>
  The <b>pm0.status</b> shows the settings of the probe-monitor,
  including which probes that are currently monitored.  Probes can be
  removed with the <b>pm0.remove-probe</b> command and it is possible
  to change the sampling settings of the probe-monitor itself with
  the <b>pm0.sampling-settings</b> command.
  </p><p>
  While the probe-monitor prints out the table data while the simulation
  is running, all data is also saved internally. To show the entire history of
  all samples, the <b>pm0.print-table</b> can be used and the data
  can also be saved into a <code>.csv</code> with
  the <b>pm0.export-table-csv</b> command. Any data in the csv
  file will be unformatted, allowing easily import in a spreadsheet
  for further analyses.
            
  </p><h2 class="jdocu"><a name="Probe-Streamer">9.2.2 Probe Streamer</a></h2>
<p>
  
</p><p>
  The <code>probe-streamer</code> tool offers a way to read out probe values
  and dump the samples in a <code>.csv</code>, while the simulation is
  running.
</p><p>
  To create a probe-streamer use the <b>new-probe-streamer</b>
  command. This will create a new object such as <code>ps0</code>
  which has some additional commands. Most of these commands are
  common to the <code>probe-monitor</code>.
  See figure <a class="reference" href="#ps-example">27</a> for an example.
</p><p>
  </p><div class="figure" id="ps-example">

    <pre class="jdocu_small">$&gt; <b>./simics targets/qsp-x86/firststeps.simics num_cores=2</b>
simics&gt; <b>new-probe-streamer mode = realtime interval = 1
csv-file-output=stream.csv</b>
    </pre><p>
  </p></div>


  <h2 class="jdocu"><a name="Probe-Based-system-perfmeter">9.2.3 Probe Based system-perfmeter</a></h2>
<p>
  
</p><p>
  This tool replaces the old <b>system-perfmeter</b> tool, which
  had similar capabilities but more monolithic, with all measurement,
  calculations and output formatting part of the tool itself.  Another
  difference is that the old <b>system-perfmeter</b> was a
  singleton object, you could not have multiple tools measuring
  different things.
</p><p>
  The <b>new-system-perfmeter</b> extends the
  <b>new-probe-monitor</b>, with some added features making it
  easier to use when measuring Simics performance:
</p><p>
  </p><ul>
    <li>Some default probes are automatically monitored.</li>
    <li>The <b>new-system-perfmeter</b> has some handy command line switches
      for easily adding additional performance related probes.</li>
  </ul>
    <p>
  See figure <a class="reference" href="#perfmeter-example">28</a> for an example.
</p><p>
  </p><div class="figure" id="perfmeter-example">

    <pre class="jdocu_small">$&gt; <b>./simics targets/qsp-x86/firststeps.simics num_cores=2</b>
simics&gt; <b>new-system-perfmeter -summary</b>
Using board.mb.cpu0.core[0][0] as clock
Enabling probes
[probes info] Enabling probes (could take a while)
[probes info] Found 330 probes using 141 different probe-kinds
[probes info] Additional probe-related command now exists under the 'probes' singleton object
[sp0 info] Added: sim:sim.time.virtual with mode session
[sp0 info] Added: sim:sim.time.wallclock with mode session
[sp0 info] Added: sim:sim.time.virtual with mode delta
[sp0 info] Added: sim:sim.time.wallclock with mode delta
[sp0 info] Added: sim:sim.slowdown with mode delta
[sp0 info] Added: sim:sim.process.cpu_percent with mode delta
[sp0 info] Added: sim:sim.load_percent with mode delta
Created sp0
simics&gt; <b>run-seconds 20</b>
┌──────────┬──────────┬─────────┬─────────┬────────┬────┬────┐
│ Session  │ Session  │Virtual- │Wallclock│Slowdown│Host│Sim │
│ Virtual- │Wallclock │Time (s) │   (s)   │        │CPU%│Load│
│   Time   │(hh:mm:ss)│         │         │        │    │ %  │
│(hh:mm:ss)│          │         │         │        │    │    │
├──────────┼──────────┼─────────┼─────────┼────────┼────┼────┤
│  00:00:00│  00:00:00│479.60 ms│215.28 ms│    0.45│118%│ 22%│
│  00:00:02│  00:00:01│  1.91 s │  1.00 s │    0.52│ 57%│  3%│
│  00:00:19│  00:00:02│ 16.47 s │999.54 ms│    0.06│114%│  0%│
┌─────┬────────────┬───────────────────────┬──────┬───────────────────────┐
│Row #│Display Name│      Probe-kind       │Object│Session Formatted Value│
├─────┼────────────┼───────────────────────┼──────┼───────────────────────┤
│    1│Virtual-Time│sim.time.virtual       │sim   │            00:00:30.00│
│    2│Wallclock   │sim.time.wallclock     │sim   │            00:00:02.83│
│    3│Slowdown    │sim.slowdown           │sim   │                   0.09│
│    4│Host CPU%   │sim.process.cpu_percent│sim   │                    93%│
│    5│Sim Load%   │sim.load_percent       │sim   │                     1%│
└─────┴────────────┴───────────────────────┴──────┴───────────────────────┘
simics&gt; q

$&gt; <b>./simics targets/qsp-x86/firststeps.simics num_cores=2</b>
simics&gt; <b>new-system-perfmeter -summary -cpu-exec-modes</b>
Using board.mb.cpu0.core[0][0] as clock
Enabling probes
[probes info] Enabling probes (could take a while)
[probes info] Found 330 probes using 141 different probe-kinds
[probes info] Additional probe-related command now exists under the 'probes' singleton object
[sp0 info] Added: sim:sim.time.virtual with mode session
[sp0 info] Added: sim:sim.time.wallclock with mode session
[sp0 info] Added: sim:sim.time.virtual with mode delta
[sp0 info] Added: sim:sim.time.wallclock with mode delta
[sp0 info] Added: sim:sim.slowdown with mode delta
[sp0 info] Added: sim:sim.process.cpu_percent with mode delta
[sp0 info] Added: sim:sim.load_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[0][0]:cpu.exec_mode.hypersim_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[1][0]:cpu.exec_mode.hypersim_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[0][0]:cpu.exec_mode.vmp_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[1][0]:cpu.exec_mode.vmp_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[0][0]:cpu.exec_mode.jit_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[1][0]:cpu.exec_mode.jit_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[0][0]:cpu.exec_mode.interpreter_percent with mode delta
[sp0 info] Added: board.mb.cpu0.core[1][0]:cpu.exec_mode.interpreter_percent with mode delta
Created sp0
simics&gt; <b>run-seconds 30</b>
┌────────────────────────────────────────────────────────────┬───────────────────┬───────────────────┐
│                                                            │  board.mb.cpu0.   │  board.mb.cpu0.   │
│                                                            │    core[0][0]     │    core[1][0]     │
├──────────┬──────────┬─────────┬─────────┬────────┬────┬────┼────┬────┬────┬────┼────┬────┬────┬────┤
│ Session  │ Session  │Virtual- │Wallclock│Slowdown│Host│Sim │HYP%│VMP%│JIT%│INT%│HYP%│VMP%│JIT%│INT%│
│ Virtual- │Wallclock │Time (s) │   (s)   │        │CPU%│Load│    │    │    │    │    │    │    │    │
│   Time   │(hh:mm:ss)│         │         │        │    │ %  │    │    │    │    │    │    │    │    │
│(hh:mm:ss)│          │         │         │        │    │    │    │    │    │    │    │    │    │    │
├──────────┼──────────┼─────────┼─────────┼────────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤
│  00:00:01│  00:00:00│508.60 ms│390.61 ms│    0.77│ 71%│ 21%│  0%│100%│  0%│  0%│  0%│ 63%│  4%│ 33%│
│  00:00:03│  00:00:01│  2.36 s │  1.00 s │    0.42│ 71%│  3%│  0%│ 99%│  1%│  0%│  0%│ 40%│ 25%│ 35%│
│  00:00:21│  00:00:02│ 17.71 s │  1.00 s │    0.06│113%│  0%│  0%│ 98%│  1%│  1%│-   │-   │-   │-   │
┌─────┬────────────┬─────────────────────────────────┬────────────────────────┬───────────────────────┐
│Row #│Display Name│           Probe-kind            │         Object         │Session Formatted Value│
├─────┼────────────┼─────────────────────────────────┼────────────────────────┼───────────────────────┤
│    1│Virtual-Time│sim.time.virtual                 │sim                     │            00:00:30.00│
│    2│Wallclock   │sim.time.wallclock               │sim                     │            00:00:02.92│
│    3│Slowdown    │sim.slowdown                     │sim                     │                   0.10│
│    4│Host CPU%   │sim.process.cpu_percent          │sim                     │                    92%│
│    5│Sim Load%   │sim.load_percent                 │sim                     │                     1%│
│    6│HYP%        │cpu.exec_mode.hypersim_percent   │board.mb.cpu0.core[0][0]│                     0%│
│    7│VMP%        │cpu.exec_mode.vmp_percent        │board.mb.cpu0.core[0][0]│                    99%│
│    8│JIT%        │cpu.exec_mode.jit_percent        │board.mb.cpu0.core[0][0]│                     0%│
│    9│INT%        │cpu.exec_mode.interpreter_percent│board.mb.cpu0.core[0][0]│                     0%│
│   10│HYP%        │cpu.exec_mode.hypersim_percent   │board.mb.cpu0.core[1][0]│                     0%│
│   11│VMP%        │cpu.exec_mode.vmp_percent        │board.mb.cpu0.core[1][0]│                    52%│
│   12│JIT%        │cpu.exec_mode.jit_percent        │board.mb.cpu0.core[1][0]│                    14%│
│   13│INT%        │cpu.exec_mode.interpreter_percent│board.mb.cpu0.core[1][0]│                    34%│
└─────┴────────────┴─────────────────────────────────┴────────────────────────┴───────────────────────┘
simics&gt; 
    </pre><p>
  </p></div>

<p>
  In the first run, only the default probes are used. The <code>-summary</code> switch automatically prints
  the value of the collected probes when Simics stops. In the second run, the <code>-cpu-exec-modes</code>
  is added, causing 8 additional probes to be monitored.
            
</p>
<div class="chain">
<a href="probes-command-set.html">9.1 Probes Command Set</a>
<a href="low-level-debugging.html">III Low-Level Debugging</a>
</div>